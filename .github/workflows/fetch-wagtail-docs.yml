name: Fetch Wagtail Docs

on:
  schedule:
    # Run at midnight UTC every day
    - cron: '0 0 * * *'
  workflow_dispatch: # Allow manual triggering

# Add permissions required for pushing to the repo
permissions:
  contents: write

jobs:
  fetch-docs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        # Fetch full history needed for checking existing tags/files and pushing
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install files-to-prompt ttok # Combine installs

      - name: Fetch latest Wagtail release info using gh CLI
        id: fetch-release
        # Use gh cli and jq for a cleaner way to get release info
        # Ensure GH_TOKEN is available for API calls (usually automatic)
        run: |
          set -e # Exit immediately if a command exits with a non-zero status.
          RELEASE_INFO=$(gh release list -R wagtail/wagtail -L 1 --json tagName,zipballUrl)
          if [ -z "$RELEASE_INFO" ]; then
            echo "Error: Failed to fetch release info from GitHub API."
            exit 1
          fi
          VERSION=$(echo "$RELEASE_INFO" | jq -r '.tagName')
          DOWNLOAD_URL=$(echo "$RELEASE_INFO" | jq -r '.zipballUrl')

          if [ -z "$VERSION" ] || [ "$VERSION" == "null" ] || [ -z "$DOWNLOAD_URL" ] || [ "$DOWNLOAD_URL" == "null" ]; then
            echo "Error: Could not parse version or download URL from release info."
            echo "API Response: $RELEASE_INFO"
            exit 1
          fi

          echo "WAGTAIL_VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "WAGTAIL_DOWNLOAD_URL=${DOWNLOAD_URL}" >> $GITHUB_OUTPUT
          echo "OUTPUT_FILENAME=wagtail-docs-${VERSION}.txt" >> $GITHUB_OUTPUT

          echo "Latest Wagtail version: $VERSION"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Provide token for gh cli

      - name: Check if documentation already exists
        id: doc_exists
        run: |
          OUTPUT_FILENAME="${{ steps.fetch-release.outputs.OUTPUT_FILENAME }}"
          echo "Checking for file: $OUTPUT_FILENAME"
          if [ -f "$OUTPUT_FILENAME" ]; then
            echo "Documentation for Wagtail ${{ steps.fetch-release.outputs.WAGTAIL_VERSION }} already exists, skipping."
            echo "DOC_EXISTS=true" >> $GITHUB_OUTPUT
          else
            echo "Documentation file does not exist, proceeding."
            echo "DOC_EXISTS=false" >> $GITHUB_OUTPUT
          fi

      # Group download, extract, process, and cleanup under one conditional step
      # for better readability, or keep separate if preferred.
      - name: Download, Process, and Cleanup
        if: steps.doc_exists.outputs.DOC_EXISTS == 'false'
        run: |
          set -e # Exit on error
          TEMP_DIR="temp_wagtail"
          WAGTAIL_VERSION="${{ steps.fetch-release.outputs.WAGTAIL_VERSION }}"
          DOWNLOAD_URL="${{ steps.fetch-release.outputs.WAGTAIL_DOWNLOAD_URL }}"
          OUTPUT_FILENAME="${{ steps.fetch-release.outputs.OUTPUT_FILENAME }}"

          echo "Creating temporary directory $TEMP_DIR..."
          mkdir -p "$TEMP_DIR"

          echo "Downloading Wagtail $WAGTAIL_VERSION from $DOWNLOAD_URL..."
          curl -L "$DOWNLOAD_URL" -o "$TEMP_DIR/wagtail.zip"

          echo "Extracting Wagtail..."
          unzip -q "$TEMP_DIR/wagtail.zip" -d "$TEMP_DIR/"
          # Find the extracted directory (robustly handles potential hash in name)
          EXTRACTED_DIR=$(find "$TEMP_DIR" -maxdepth 1 -type d -name 'wagtail-wagtail-*' | head -n 1)
          if [ -z "$EXTRACTED_DIR" ]; then
            echo "Error: Could not find extracted Wagtail directory in $TEMP_DIR"
            ls -la "$TEMP_DIR" # List contents for debugging
            exit 1
          fi
          WAGTAIL_DOCS_DIR="$EXTRACTED_DIR/docs"
          echo "Found Wagtail docs at: $WAGTAIL_DOCS_DIR"

          echo "Processing documentation..."
          # Ensure the docs directory exists
          if [ ! -d "$WAGTAIL_DOCS_DIR" ]; then
             echo "Error: Documentation directory '$WAGTAIL_DOCS_DIR' not found after extraction."
             ls -la "$EXTRACTED_DIR" # List contents for debugging
             exit 1
          fi
          # Run files-to-prompt from the correct directory
          files-to-prompt "$WAGTAIL_DOCS_DIR" -e md -e rst --ignore "releases" --ignore "README.md" -c > "$GITHUB_WORKSPACE/$OUTPUT_FILENAME"

          # Verify output file creation
          if [ ! -f "$GITHUB_WORKSPACE/$OUTPUT_FILENAME" ]; then
            echo "Error: Output file $GITHUB_WORKSPACE/$OUTPUT_FILENAME was not created by files-to-prompt."
            exit 1
          fi
          echo "Documentation processed into $OUTPUT_FILENAME."

          echo "Cleaning up temporary files..."
          rm -rf "$TEMP_DIR"
          echo "Cleanup complete."

      - name: Calculate token count and update README
        if: steps.doc_exists.outputs.DOC_EXISTS == 'false'
        run: |
          set -e
          OUTPUT_FILENAME="${{ steps.fetch-release.outputs.OUTPUT_FILENAME }}"
          echo "Calculating token count for $OUTPUT_FILENAME..."
          # Use ttok command line tool
          TTOK_COUNT=$(cat "$GITHUB_WORKSPACE/$OUTPUT_FILENAME" | ttok)
          if ! [[ "$TTOK_COUNT" =~ ^[0-9]+$ ]]; then
             echo "Error: Failed to get valid token count from ttok. Output: $TTOK_COUNT"
             exit 1
          fi
          echo "Token count: $TTOK_COUNT"

          echo "Updating README.md..."
          # Pass variables as environment variables to the Python script
          export WAGTAIL_VERSION="${{ steps.fetch-release.outputs.WAGTAIL_VERSION }}"
          export TTOK_COUNT="$TTOK_COUNT"
          export OUTPUT_FILENAME="$OUTPUT_FILENAME" # Pass filename to script
          python .github/scripts/update_readme.py

      - name: Commit and push changes
        if: steps.doc_exists.outputs.DOC_EXISTS == 'false'
        run: |
          set -e
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Pull latest changes from the branch the workflow is running on (usually main/master)
          # Use GITHUB_REF_NAME which holds the branch name
          git pull origin ${GITHUB_REF_NAME}

          OUTPUT_FILENAME="${{ steps.fetch-release.outputs.OUTPUT_FILENAME }}"

          # Check if there are actual changes to commit in the specific files
          # `git diff --quiet --exit-code` exits with 0 if no changes, 1 if changes
          if ! git diff --quiet --exit-code "$GITHUB_WORKSPACE/$OUTPUT_FILENAME" README.md; then
            echo "Changes detected in $OUTPUT_FILENAME or README.md. Committing..."
            git add "$GITHUB_WORKSPACE/$OUTPUT_FILENAME" README.md
            git commit -m "Add docs for Wagtail ${{ steps.fetch-release.outputs.WAGTAIL_VERSION }} and update README"

            echo "Pushing changes..."
            # Use standard push, fail if there are upstream changes (safer than force)
            git push origin ${GITHUB_REF_NAME}
            echo "Changes pushed successfully."
          else
            echo "No changes detected in $OUTPUT_FILENAME or README.md. Nothing to commit."
          fi
